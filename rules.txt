▪️Building the thing

Draw the pipes on paper, this helps, a lot. Before writing to the outfile, make sure you read from the correct end of the correct pipe.

Here I'll give you some checklist on what you have to do to achieve this project.
Main checklist

- Check the existence of infile and outfile ✔
	- be sure to understand what > does when the file does not exist

- Create the necessary pipe (or pipes)

- Create a child process for each command

- Wait for all the processes to end before writing to the outfile

When using here_doc, the second argument is not a command ;)

Execute checklist

Remember that the execve() function needs the path to a binary file as parameter,
so you'll have to find where the commands binaries are stored on your computer.
Before going further, you have to know how to find any command binary.

- Check in all possible locations if the binary (command) requested by the user exists.

- "Build" the arguments array for the command.

- Execute the command using execve()


PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/munki

OLD MAIN :
/* int	main(int argc, char **argv, char **env)
{
	int		infile;
	int		outfile;
	int		pipe_fd[2];
	char	*path_cmd1;
	char	*path_cmd2;
	char	**cmd1_args;
	char	**cmd2_args;
	pid_t	child1;
	pid_t	child2;

	if (argc != 5)
	{
		ft_printf("Error -> usage : [ ./pipex file1 cmd1 cmd2 file2 ]\n");
		return (1);
	}
	else
	{
		if (open(argv[1], O_RDONLY) < 0)
			file_error();
		if ((open(argv[4], O_WRONLY | O_TRUNC | O_CREAT, 0777)) < 0)
			file_error();
		cmd1_args = ft_split(argv[2], ' ');
		cmd2_args = ft_split(argv[3], ' ');
		path_cmd1 = build_path(cmd1_args[0], env);
		path_cmd2 = build_path(cmd2_args[0], env);
		if (!path_cmd1 || !path_cmd2 || !cmd1_args || !cmd2_args)
		{
			free_all(path_cmd1, path_cmd2, cmd1_args, cmd2_args);
			ft_printf("Error : Non valid command\n");
			exit(1);
		}
		pipe(pipe_fd);
		child1 = fork();
		if (child1 == 0)
		{
			infile = open(argv[1], O_RDONLY);
			dup2(infile, STDIN_FILENO); // Redirect stdin to infile
			close(infile);
			dup2(pipe_fd[1], STDOUT_FILENO);
			close(pipe_fd[0]);
			// Execute cmd1
			execve(path_cmd1, cmd1_args, env);
			exit(1);
		}
		child2 = fork();
		if (child2 == 0)
		{
			outfile = open(argv[4], O_WRONLY | O_TRUNC | O_CREAT, 0777);
			dup2(pipe_fd[0], STDIN_FILENO);
			close(pipe_fd[1]);
			dup2(outfile, STDOUT_FILENO); // Redirect stdout to outfile
			close(outfile);
			execve(path_cmd2, cmd2_args, env);
			exit(1);
		}
		if (ft_strncmp(cmd1_args[0], "sleep", 5) == 0
			|| ft_strncmp(cmd2_args[0], "sleep", 5) == 0)
		{
			waitpid(child1, NULL, 0);
			waitpid(child2, NULL, 0);
		}
		// Free allocated resources
		free_all(path_cmd1, path_cmd2, cmd1_args, cmd2_args);
		exit(1);
	}
	return (0);
} */